#State Estimation of a Two-Wheeled Car
This is the webpage for Team Velma's submission for lab 4 of EE183DA Winter 2017, taught by Professor Ankur Mehta.
##Introduction
In this lab, we consider a small, two-wheeled car controlled by a microcontroller.  A sample car fitting this description is shown in figure 1.<br>
![alt text][car]<br>
*figure 1: sample small, two-wheeled car (image courtesy of lab 4 specifications)*<br>
This car is driven by two continuous servos, one for each wheel.  Each servo is driven by a pulse-width modulation (PWM) input from the on-board microcontroller.  When the servos are driven, the state of the vehicle, consisting of the x,y coordinate relative to some origin of the car, its rotation relative to some axis, and the time derivatives of those three values, changes.  Our goal in this lab is to be able to measure the state of the vehicle as accurately as possible given the inputs sent to the servos as well as noisy sensor data that provides a partial understanding of the vehicle state.
##Simulation
Rather than physically construct this small, two-wheeled car, our team chose to simulate its operation.  This simulation operates simply at a high level: receive PWM inputs, add some noise to these inputs, use the noisy PWM inputs to generate the actual RPM and direction of each servo, and lastly model the sensing of the RPM/direction data.  
###Sensor Choice
The original lab specification provides for IR sensors attached to each servo that produce a HIGH/LOW signal based on the position of the wheel, which had twenty alternating white/black colored circular sectors.  We found that this was not an ideal sensing solution for state estimation.  In the described configuration, the IR sensor could measure to the precision of 1/20th of a rotation; at our applied rotational speeds and sensing rates, this generated an extremely inaccurate state estimate as the measured RPMs would be zero for a few cycles and then spike to 60RPM for one 2ms cycle before returning to zero.<br>
Instead of the IR sensor, our group decided to simulate the use of a rotary encoder.  A rotary encoder provides a measure of both the RPM of the shaft it is attached to (after some simple processing) as well as the direction of shaft rotation.  The rotary encoder we chose to simulate can measure 2500 pulses per revolution, meaning that it can measure to the nearest .0004 of a rotation of the attached shaft.  We chose to simulate the presence of a rotary encoder on each servo output shaft, giving us an RPM for each wheel.
###PWM Inputs
The two servos on the vehicle take in a PWM signal and then process the input signal into rotational motion.  We consider the PWM frequency of our system to be 500Hz, meaning that each PWM period is exactly 2ms.  Per the data sheet of the continuous servo used, within the context of 500Hz PWM we can say that a 2ms pulse width is equal to full-speed counterclockwise rotation of the servo, a 1.5ms pulse width (along with a small deadband around 1.5ms) is equal to no change in the rotation of the servo and that a 1ms pulse width is equal to full-speed clockwise rotation of the servo.<br>
During operation of the vehicle, we assume that the user will only send signals with widths of 1ms, 1.5ms or 2ms (this assumption is elaborated later on).  Due to both limitations of the microcontroller sending the PWM signal, limitations of the servo and loss on the wire, we assume that the final interpreted PWM signal will never be exactly 1ms, 1.5ms or 2ms.  Instead, we model that for each input width there is a range of values which the final interpreted PWM signal will fall on:<br>
+ 1ms: final value will lie between 1ms and 1.1ms 
+ 1.5ms: final value will lie between 1.49ms and 1.51ms
+ 2ms: final value will lie between 1.9ms and 2ms

Note that for 1.5ms, the final interpreted value is much closer to the actual input than for the other options.  This is due to the consideration of the deadband around 1.5ms input which ensures that at values close to 1.5ms there is no motion; we consider this deadband by putting it entirely at 1.5ms and moving up the values that would have been immediately on each side of the deadband to be adjacent to 1.5ms.  For both 1ms and 2ms, it is possible that the signal could be less than 1ms or greater than 2ms; however, we consider any pulse width reasonably close to but lower than 1ms to be equivalent to 1ms and pulse widths greater than 2ms will simply blend into the next PWM period.
###Generation of RPM
Through some testing with a sample load and the rotary encoder, we determined that the max RPM achieved at both 1ms and 2ms was roughly 65RPM.  We classify a positive RPM value to be attained when the servo is rotating counterclockwise (i.e. pulse width > 1.5ms) and a negative RPM value to be attained when the servo is rotating clockwise (i.e. pulse width < 1.5ms).  Thus, we can generate a mathematical equation to convert from PWM input in each servo to RPM in each servo:<br>
![alt text][equation1]<br>
At each 2ms step, we read the pulse width input, corrupt it as described above, and generate the true RPM of each servo. 
###Sensing of RPM
As discussed previously, the RPM is instantaneously sensed by the rotary encoder which is then pinged.  We assume that each servo will base its RPM based on the previous cycle's PWM input and that it will instanteously update to its new RPM at the start of the next cycle.  We assume that the rotary encoder is sensitive enough to measure this new change and provide an updated result within a negligible time span.  However, we assume that this limited sampling of the new RPM of each servo introduces a large error to the rotary encoder and that the sensed RPM will be +/- 10% of the true value rounded to the nearest .0004RPM to meet the measurement limitation of the rotary encoder.  Thus, the simulated sensor output consists of the sensed RPM at the end of each 2ms cycle accurate within 10% of the true value and precise to the nearest .0004RPM.
##State Estimation
Our goal is to use the noisy sensor measurements as well as the system inputs (before the addition of noise) to create a picture of the robot's state that is as accurate as possible.  The first step toward this goal is fully defining the state of the robot and determining how we can transition from the servo RPMs to the state of the robot.
###State Description
The robot's state consists of the position of the robot, {x,y}, its orientation, theta, and the velocities of those 3 variables.  {x,y} are the horizontal and vertical displacements of some center point of the vehicle from the origin respectively and theta is the direction the car is pointing measured as a rotation from the right horizontal axis.  The 3 velocities are the instantaneous rates at which these state variables are changing.  Figure 2 provides a picture demonstrating {x, y, theta}.<br>
![alt text][defxyt]<br>
*figure 2: demonstration of x, y, and theta*<br>
###State Evolution: Position and Orientation
We need a way to evolve the state of the car over time.  At each step, the state of the vehicle will be a function of both its previous state and previous input.  We assume that the initial state of the car is initially all 0: the car is at the origin, pointing right horizontally and has no velocity.  For the first two milliseconds, the vehicle is defined by this state as the servo reads the PWM input.  At t=2ms, the servos are driven: some of the velocities may update, but the vehicle has not moved over that time.  At t=4ms, the state of the vehicle begins to take shape: the position and orientation of the vehicle will be updated based on the previous velocities of the system and the velocities will be updated based on the PWM read over the previous 2ms.  This state estimation process continues over the entire input period for the vehicle.  The relations are given in equation format below.<br>
![alt text][equation2]<br>
dt in the above equations is defined as the time step between state observations; in our instance, this will always be 2ms as we are choosing to update at the same rate as the PWM frequency.
###State Evolution: Velocities
Now that we have a framework for evolving the position and orientation state variables, we need a method for updating the velocity state variables at each state observation.  This will require three variables: the RPM of each wheel as well as the new theta whose calculation is described above.  Generally speaking, our car's motion is defined by five high-level possible states: forward and  backward motion (linear motion), leftward and rightward rotation (angular motion), and no motion.  We will analyze how to derive the three velocities by analysis of the RPM for each category.
####Velocity Update: Linear Motion
In order for linear motion to take place, we must drive the servos to move in opposite rotational directions, presumably at full speeds.  This corresponds to PWM inputs of either (1ms, 2ms) or (2ms, 1ms) to the left and right servo respectively.  If the left wheel is moving in a counterclockwise direction and the right wheel is moving in a clockwise direction, each wheel is rotating forward with respect to the car and thus we have forward linear motion.  If the left wheel is moving in a clockwise direction and the right wheel is moving in a counterclockwise direction, each wheel is rotating backward with respect to the car and thus we have backward linear motion.  We can logically look at the RPM of each wheel and determine if either of these cases are true.  If they are, we can compute the linear velocity of the vehicle by taking the absolute value of each RPM, averaging them, adjusting to revolutions per second and then multiplying by the circumference of the wheels (assumed to be perfectly 50mm in radius), negating this resulting value in the case of backward linear motion.  This described velocity will be in the same direction as the vehicle, which we know is some value theta; we can convert this velocity to velocity in the x and y directions by multiplying by cos(theta) and sin(theta), respectively.  We assume that with linear motion there is no change in the direction of the vehicle and thus set the directional velocity to 0.  The equations below describe the process of determining dx, dy and d(theta) in the case of forward linear motion; if reverse linear motion were the case, v would simply need to be negated.<br>
![alt text][equation3]<br>
####Velocity Update: Angular Motion
For angular motion, we drive the servos in the same direction.  If the servos are driven with (1ms, 1ms), each servo will move clockwise; this means the right servo will move forward at full RPM and the left servo will move backward at full RPM, achieving a  rotation of the car to the left.  If the servos are driven with (2ms, 2ms), each servo will move counterclockwise; this means the left servo will move forward at full RPM while the right servo will move backward at full RPM, achieving a rotation of the car to the right.  We need to determine this angular velocity.  To do so, we assume that the center of mass of the vehicle is at the exact middle point of each wheel, which is 45mm from each wheel (the axle radius).  From there, we can use the relation that tangential velocity is equal to angular velocity times radius.  We compute an average tangential velocity similarly to above: take the mean of the absolute value of each RPM, negate this value so that in both contexts the positive angular velocity will be defined as counterclockwise from the right horizontal, convert this to an average tangential velocity and then divide by the 45mm radius.  We assume that there is no change in either x or y during this process and thus dx and dy are set to 0.  The equations for this are shown below.<br>
![alt text][equation4]<br>
####Velocity Update: No Motion
In no case can we expect the motion of the car to be non-existent.  Due to PWM fluctuations, there should always be at least some minute driving in each servo.  However, if there were to be no input to the system at all, dx, dy and angular velocity would all be set to zero.
###State Estimation Method
When our simulator is ran with our input, we receive back two arrays of values: the true left/right wheel RPMs at the end of each cycle as well as the noisy left/right wheel RPMs sensed by our rotary encoder.  Beginning with a zeroed out initial state, we propagate using these RPM measurements to achieve a state observation at each 2ms point.  We find that the true state of the car at each point differs from the observed value due to the noise introduced in sensing and the rotary encoder being able to measure to only the nearest .0004 rotation (mostly the former source).  Our goal is to figure out a method of generating a state estimate at each point that is more accurate than simply following the state estimate given by the noisy sensors.  The option we decided to do this was to use a model based state estimator.  In effect, we take the inputs given to the system, apply the mean noise whenever noise is added and generate a brand new state estimation.  For instance, if we drove the system with an input of (2ms, 1ms), the state estimator would propagate using (1.95ms, 1.05ms), which are the means in the specified 1.9-2ms and 1-1.1ms ranges.  At the sensing level, we assume that there is no sensing noise and that we always measure at the exact middle of that +- 10% uncertainty band.  This provides us with a state estimation that is practically devoid of any system noise.  This compares with the true state observations, which contain more noise due to the random 1.9ms-2ms/1.49ms-1.51ms/1-1.1ms bands and the even noisier sensor observation which includes both the process and sensing noise.  Each estimate will contribute some fraction to this final state estimate; we assume that the contribution factor for each is 1/2 and thus compute our state estimate as the arithmetic mean of the noiseless and sensed state estimates.
##Evaluation of State Estimator 
We can test our state estimator by simulating various trajectories and seeing how accurate our state estimation is.  To measure accuracy, we will use the mean squared error of the state estimation.  Discussion of mean squared error as a measure can be found [here](https://en.wikipedia.org/wiki/Mean_squared_error).  We simulated five separate trajectories for the robot to follow for 30 trials each and then generated average MSE values over the 30 trials for both the sensed state estimate and the combined state estimate.  These average MSEs are presented in the table below along with a sample picture showing what the input trajectory looks like.

Trajectory | Average Sensor Estimate MSE | Average Combined Estimate MSE
--- | --- | ---
[1](http://oi66.tinypic.com/2nhqdf4.jpg) | .0050 | .0038
[2](http://oi67.tinypic.com/9qir0y.jpg) | .0022 | .0015
[3](http://oi67.tinypic.com/aw9d3d.jpg) | .0058 | .0048
[4](http://oi63.tinypic.com/4r55dt.jpg) | .0071 | .0041
[5](http://oi63.tinypic.com/28lvvhj.jpg) | .0030 | .0016

As is visible, on every trajectory tested, the mean-squared error of the combined-estimate is lower than the accurate of just the sensor-only estimate and thus is more accurate.  However, it is still fairly error prone and as is clearly visible on the trajectory graphs, the combined value is still significantly off from the true estimate.  That said, the system presents a better state estimate than simply going off of the noisy sensor outputs and is not computationally expensive to implement and thus is a semi-viable state estimator.  

To test this simulator and state estimator on your own, first clone this repo.  In estimator.m, there is a variable named "control_seq", which is an nx3 matrix.  On any row, the first column represents the left wheel PWM input (either 2, 1.5 or 1), the second column represents the right wheel PWM input (either 2, 1.5 or 1) and the third column represents the number of 2ms cycles you wish to use this input for (positive integer).  The trajectories for the five experiments above can be found in appendix A.
##Conclusion
Ultimately, we were able to produce a semi-competent state estimator by averaging a noiseless model of our system with the measured very noisy sensor inputs of our system in order to attempt to estimate the middle ground, the somewhat noise corrupted true state of the system.  While we found that this method of state estimation does reduce the error in the state estimate, it does not provide a perfect state estimate and has suspect practical usability.  Given more time, a different state estimation algorithm such as the Kalman filter could have been applied to our system in order to produce more accurate and usable results.  Also, the assumption of equal weighting between the noiseless state estimate and the noisy sensor state estimate is likely unrealistic (i.e. each constitutes 1/2 of the final state estimation); more fine tuned weighting factors could be computed to increase the accuracy (e.g. have the noiseless state estimate contribute 3/4 of the final state estimation and have the sensed state estimate be 1/4).
##Appendix A: Trajectory Control Sequences
Trajectory 1: control_seq = [2 2 15; 1 2 30; 2 1 90; 1 1 30; 1 2 30; 2 2 50; 1 2 5; 2 2 10; 2 1 50; 2 2 10; 1.5 1.5 5; 2 1 10; 2 2 15; 1 2 5; 2 2 10; 2 1 30];
Trajectory 2: control_seq = [1 1 10; 2 1 50; 2 2 10; 1 2 60; 2 2 5; 2 1 30];
Trajectory 3: control_seq = [2 1 50; 2 2 5; 1 2 10; 1 1 10; 2 2 5; 1 1 10];
Trajectory 4: control_seq = [1 1 30; 2 1 10; 1 1 5; 1 2 33; 2 2 6; 1 2 5];
Trajectory 5: control_seq = [1 2 13; 2 1 25; 1 1 5; 2 1 50; 2 2 10; 1 2 36; 2 2 10; 1 2 6];


[car]: http://i.imgur.com/DzEnqye.png
[equation1]: http://i.imgur.com/oc8IY5Q.png
[equation2]: http://i.imgur.com/SSDD72g.png
[equation3]: http://i.imgur.com/nkErdPU.png
[equation4]: http://i.imgur.com/OM1x5SG.png
[defxyt]: http://i.imgur.com/w2YaFh0.png
